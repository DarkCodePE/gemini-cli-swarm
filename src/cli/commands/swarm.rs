// ============================================================================
// SWARM COMMAND - Integrado con Cost Optimization y Performance Monitoring
// ============================================================================

use crate::{
    swarm::{SwarmOrchestrator, SwarmConfig, TaskBuilder, TaskType, TaskPriority},
    adapters::AdapterConfig,
    cost_optimizer::{CostConstraints, PriorityLevel, ModelChoice},
    performance::AlertThresholds,
    ThinkingMode,
};
use chrono;
use clap::Args;
use colored::*;
use indicatif::{ProgressBar, ProgressStyle};
use std::collections::HashMap;
use std::time::Duration;

#[derive(Args)]
pub struct SwarmArgs {
    /// La tarea a ejecutar
    pub task: String,

    /// Activar modo Gemini CLI
    #[arg(long)]
    pub gemini: bool,

    /// Modo thinking habilitado  
    #[arg(long)]
    pub thinking: bool,

    /// Modo thinking avanzado con pasos intermedios
    #[arg(long)]
    pub thinking_verbose: bool,

    /// L√≠mite de costo por tarea en USD
    #[arg(long, value_name = "USD")]
    pub max_cost: Option<f64>,

    /// Presupuesto diario en USD
    #[arg(long, value_name = "USD")]
    pub daily_budget: Option<f64>,

    /// Prioridad de la tarea (low, medium, high, critical)
    #[arg(long, value_enum, default_value = "medium")]
    pub priority: CliPriority,

    /// Selecci√≥n espec√≠fica de modelo
    #[arg(long, value_enum)]
    pub model: Option<CliModelChoice>,

    /// Mostrar m√©tricas de performance en tiempo real
    #[arg(long)]
    pub metrics: bool,

    /// Exportar reporte detallado al finalizar
    #[arg(long)]
    pub export_report: bool,

    /// Mostrar recomendaciones de optimizaci√≥n
    #[arg(long)]
    pub recommendations: bool,

    /// Modo verboso para debugging
    #[arg(long, short)]
    pub verbose: bool,
}

#[derive(clap::ValueEnum, Clone, Debug, Copy)]
pub enum CliPriority {
    Low,
    Medium,
    High,
    Critical,
}

impl From<CliPriority> for TaskPriority {
    fn from(cli_priority: CliPriority) -> Self {
        match cli_priority {
            CliPriority::Low => TaskPriority::Low,
            CliPriority::Medium => TaskPriority::Medium,
            CliPriority::High => TaskPriority::High,
            CliPriority::Critical => TaskPriority::Critical,
        }
    }
}

#[derive(clap::ValueEnum, Clone, Debug)]
pub enum CliModelChoice {
    Gemini15Flash,
    Gemini15Pro,
    Gemini15ProExp,
    Auto,
}

impl From<CliModelChoice> for ModelChoice {
    fn from(cli_model: CliModelChoice) -> Self {
        match cli_model {
            CliModelChoice::Gemini15Flash => ModelChoice::Gemini15Flash,
            CliModelChoice::Gemini15Pro => ModelChoice::Gemini15Pro,
            CliModelChoice::Gemini15ProExp => ModelChoice::Gemini15ProExp,
            CliModelChoice::Auto => ModelChoice::Auto,
        }
    }
}

pub async fn execute_swarm_command(args: SwarmArgs) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    if args.verbose {
        println!("{}", "üîç Modo verboso activado".bright_blue());
        env_logger::builder()
            .filter_level(log::LevelFilter::Debug)
            .init();
    }

    println!("{}", "üöÄ Inicializando Enjambre Swarm v2.0".bright_green().bold());
    println!("{}", "üí° Con Cost Optimization y Performance Monitoring".bright_cyan());
    println!();

    let cost_constraints = CostConstraints {
        max_cost_per_request: args.max_cost,
        daily_budget: args.daily_budget,
        priority: match args.priority {
            CliPriority::Low => PriorityLevel::Low,
            CliPriority::Medium => PriorityLevel::Medium,
            CliPriority::High => PriorityLevel::High,
            CliPriority::Critical => PriorityLevel::Critical,
        },
    };

    let alert_thresholds = AlertThresholds::default();

    let swarm_config = SwarmConfig {
        max_concurrent_tasks: 4,
        default_adapter: if args.gemini { "gemini".to_string() } else { "gemini".to_string() },
        enable_neural_selection: true,
        enable_adaptive_learning: true,
        performance_monitoring: true,
        cost_optimization: true,
        cost_constraints,
        alert_thresholds,
    };

    let spinner = ProgressBar::new_spinner();
    spinner.set_style(ProgressStyle::default_spinner()
        .template("{spinner:.green} {msg}")
        .unwrap());
    spinner.set_message("Inicializando adaptadores optimizados...");
    spinner.enable_steady_tick(Duration::from_millis(100));

    let mut orchestrator = SwarmOrchestrator::new(swarm_config);

    let mut adapter_configs = HashMap::new();
    
    let api_key = std::env::var("GEMINI_API_KEY")
        .or_else(|_| std::env::var("GOOGLE_API_KEY"))
        .unwrap_or_else(|_| {
            spinner.finish_with_message("‚ö†Ô∏è No se encontr√≥ API key");
            eprintln!("{}", "‚ö†Ô∏è  ADVERTENCIA: No se encontr√≥ GEMINI_API_KEY en variables de entorno".yellow());
            eprintln!("{}", "   Configura tu API key con: export GEMINI_API_KEY=your_api_key".cyan());
            String::new()
        });

    if !api_key.is_empty() {
        let adapter_config = AdapterConfig {
            api_key,
            base_url: None,
            timeout_seconds: 120,
            max_attempts: 3,
            enable_verification: true,
            project_id: std::env::var("GOOGLE_PROJECT_ID").ok(),
            location: std::env::var("GOOGLE_LOCATION").ok(),
        };

        adapter_configs.insert("gemini".to_string(), adapter_config);
    }

    match orchestrator.initialize(adapter_configs).await {
        Ok(_) => {
            spinner.finish_with_message("‚úÖ Adaptadores inicializados correctamente");
        }
        Err(e) => {
            spinner.finish_with_message("‚ùå Error en inicializaci√≥n");
            eprintln!("{} {}", "Error:".red().bold(), e);
            return Err(e.into());
        }
    }

    println!();
    println!("{}", "üìã Configurando tarea...".bright_blue());

    let mut task_builder = TaskBuilder::new(TaskType::CodeGeneration, args.task.clone())
        .with_priority(args.priority.into());

    if args.thinking_verbose {
        task_builder = task_builder.with_thinking_mode(ThinkingMode::StepByStep { show_intermediate: true });
        println!("  üß† Modo thinking: Paso a paso con detalles");
    } else if args.thinking {
        task_builder = task_builder.with_thinking_mode(ThinkingMode::Extended { max_thinking_time_ms: 30000 });
        println!("  üß† Modo thinking: Extendido");
    }

    if let Some(max_cost) = args.max_cost {
        task_builder = task_builder.with_max_cost(max_cost);
        println!("  üí∞ L√≠mite de costo: ${:.3}", max_cost);
    }

    let task = task_builder.build();

    println!("  üìù Descripci√≥n: {}", args.task.bright_white());
    println!("  üéØ Prioridad: {:?}", args.priority);
    if let Some(model) = &args.model {
        println!("  ü§ñ Modelo espec√≠fico: {:?}", model);
    } else {
        println!("  ü§ñ Modelo: Selecci√≥n autom√°tica optimizada");
    }

    if args.metrics || args.recommendations {
        println!();
        println!("{}", "üìä An√°lisis de optimizaci√≥n...".bright_cyan());
        
        let current_metrics = orchestrator.get_performance_metrics();
        let optimization_stats = orchestrator.get_optimization_stats();

        if args.metrics {
            println!("  üìà Success Rate Actual: {:.1}%", current_metrics.success_rate * 100.0);
            println!("  ‚è±Ô∏è Avg. Response Time: {}ms", current_metrics.average_response_time_ms);
            println!("  üí∞ Ahorro Total: ${:.3}", optimization_stats.total_cost_saved);
        }

        if args.recommendations && !optimization_stats.recommendations.is_empty() {
            println!("  üí° Recomendaciones:");
            for rec in &optimization_stats.recommendations {
                println!("    - Modelo {:?}: {}", rec.model, rec.reason.bright_yellow());
                println!("      Costo Estimado: ${:.4}, Confianza: {:.1}%", rec.estimated_cost, rec.confidence * 100.0);
            }
        }
    }

    println!();
    println!("{}", "‚ö° Ejecutando tarea con optimizaciones...".bright_green().bold());

    let execution_bar = ProgressBar::new_spinner();
    execution_bar.set_style(ProgressStyle::default_spinner()
        .template("{spinner:.cyan} {msg}")
        .unwrap());
    execution_bar.set_message("Analizando complejidad y seleccionando modelo √≥ptimo...");
    execution_bar.enable_steady_tick(Duration::from_millis(120));

    let start_time = std::time::Instant::now();
    let result = orchestrator.execute_task(task).await;
    let execution_time = start_time.elapsed();

    execution_bar.finish_and_clear();

    println!();
    if result.success {
        println!("{}", "üéâ ¬°Tarea completada exitosamente!".bright_green().bold());
        
        println!();
        println!("{}", "üìä M√©tricas de Optimizaci√≥n:".bright_cyan().bold());
        println!("  ü§ñ Modelo usado: {:?}", result.selected_model);
        println!("  üîß Adaptador: {}", result.selected_adapter);
        println!("  ‚è±Ô∏è  Tiempo total: {:.2}s", execution_time.as_secs_f64());
        println!("  üí∞ Costo real: ${:.4}", result.cost_actual);
        
        if result.cost_saved > 0.0 {
            println!("  üíö Ahorro vs modelo caro: ${:.4}", result.cost_saved);
            let savings_percent = (result.cost_saved / (result.cost_actual + result.cost_saved)) * 100.0;
            println!("  üìà Ahorro porcentual: {:.1}%", savings_percent);
        }
        
        println!("  üéØ Score de performance: {:.1}%", result.performance_score * 100.0);

        if let Some(code_result) = &result.result {
            println!();
            println!("{}", "üìù Resultado Generado:".bright_white().bold());
            println!("{}", "‚îÄ".repeat(60).bright_black());
            println!("{}", code_result.code);
            println!("{}", "‚îÄ".repeat(60).bright_black());
            
            println!();
            println!("{}", "üîç Detalles T√©cnicos:".bright_blue());
            println!("  üìã Lenguaje: {}", code_result.language);
            println!("  üéØ Confianza: {:.1}%", code_result.confidence_score * 100.0);
            println!("  üîÑ Intentos: {}", code_result.attempts_made);
            println!("  ‚úÖ Verificaci√≥n: {}", if code_result.verification_passed { "Pas√≥ ‚úì" } else { "Fall√≥ ‚úó" });
        }

        if let Some(thinking_result) = &result.thinking_result {
            println!();
            println!("{}", "üß† Proceso de Razonamiento:".bright_magenta().bold());
            for (i, step) in thinking_result.reasoning_trace.iter().enumerate() {
                println!("  {}. {}", i + 1, step);
            }
            
            if !thinking_result.intermediate_conclusions.is_empty() {
                println!();
                println!("{}", "üí° Conclusiones Intermedias:".bright_yellow());
                for conclusion in &thinking_result.intermediate_conclusions {
                    println!("  ‚Ä¢ {}", conclusion);
                }
            }
            
            println!("  ‚è±Ô∏è Tiempo de thinking: {:.2}s", thinking_result.thinking_time_ms as f64 / 1000.0);
        }

    } else {
        println!("{}", "‚ùå Error en la ejecuci√≥n".bright_red().bold());
        if let Some(error) = &result.error {
            println!("  üìù Detalle: {}", error.red());
        }
    }

    let performance_report = orchestrator.get_performance_report();
    if !performance_report.alerts.is_empty() {
        println!();
        println!("{}", "‚ö†Ô∏è Alertas de Performance:".bright_yellow().bold());
        for alert in &performance_report.alerts {
            let severity_icon = match alert.severity {
                crate::performance::AlertSeverity::Low => "üîµ",
                crate::performance::AlertSeverity::Medium => "üü°",
                crate::performance::AlertSeverity::High => "üü†",
                crate::performance::AlertSeverity::Critical => "üî¥",
            };
            println!("  {} {}: {}", severity_icon, alert.metric_name, alert.message);
            println!("    Valor: {:.2}, Umbral: {:.2}", alert.current_value, alert.threshold);
        }
    }

    if args.export_report {
        println!();
        println!("{}", "üìÑ Exportando reporte detallado...".bright_blue());
        
        match orchestrator.export_detailed_metrics() {
            Ok(json_report) => {
                let filename = format!("enjambre_report_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S"));
                std::fs::write(&filename, json_report)?;
                println!("  ‚úÖ Reporte guardado: {}", filename.bright_green());
            }
            Err(e) => {
                println!("  ‚ùå Error exportando reporte: {}", e.to_string().red());
            }
        }
    }

    if args.metrics {
        println!();
        println!("{}", "üìä Comparaci√≥n de Performance:".bright_cyan().bold());
        let comparison = orchestrator.get_optimization_stats().claude_flow_comparison;
        
        println!("  üéØ Success Rate:");
        println!("    Target: {:.1}%", comparison.target_success_rate * 100.0);
        println!("    Actual: {:.1}%", comparison.current_success_rate * 100.0);
        
        if comparison.current_success_rate >= comparison.target_success_rate {
            println!("    {} ¬°Objetivo alcanzado!", "‚úÖ".bright_green());
        } else {
            println!("    {} Gap: {:.1}%", "üìà".bright_yellow(), comparison.performance_gap * 100.0);
        }
        
        println!("  ‚ö° Speed Improvement:");
        println!("    Target: {:.1}x", comparison.target_speed_improvement);
        println!("    Actual: {:.1}x", comparison.current_speed_improvement);
        
        if comparison.current_speed_improvement >= comparison.target_speed_improvement {
            println!("    {} ¬°Objetivo alcanzado!", "‚úÖ".bright_green());
        } else {
            println!("    {} Necesita mejora", "üìà".bright_yellow());
        }
    }

    println!();
    println!("{}", "üéØ Ejecuci√≥n completada".bright_green().bold());
    
    Ok(())
} 